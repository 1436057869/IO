1.继承 Thread 类，重写父类 run()方法
2.实现 runnable 接口
3.使用 ExecutorService、Callable、Future 实现有返回结果的多线程(JDK5.0 以后)


多线程同步机制。
在需要同步的方法的方法签名中加入 synchronized 关键字。
使用 synchronized 块对需要进行同步的代码段进行同步。
使用 JDK 5 中提供的 java.util.concurrent.lock 包中的 Lock 对象。
一段 synchronized 的代码被一个线程执行之前，他要先拿到执行这段代码的权限，在 java
里边就是拿到某个同步对象的?（一个对象只有一把?）； 如果这个时候同步对象的?被其
他线程拿走了，他（这个线程）就只能等了（线程阻塞在?池 等待队列中）。 取到?后，
他就开始执行同步代码(被 synchronized 修饰的代码）；线程执行完同步代码后马上就把?还
给同步对象，其他在?池中 等待的某个线程就可以拿到?执行同步代码了。这样就保证了
同步代码在统一时刻只有一个线程在执行。


线程的几种可用状态。
线程在执行过程中，可以处于下面几种状态：
就绪(Runnable):线程准备运行，不一定立马就能开始执行。
运行中(Running)：进程正在执行线程的代码。
等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。
睡眠中(Sleeping)：线程被强制睡眠。
I/O 阻塞(Blocked on I/O)：等待 I/O 操作完成。
同步阻塞(Blocked on Synchronization)：等待获取?。
死亡(Dead)：线程完成了执行。


什么是死?(deadlock)？
两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死?。结果就是两个进程
都陷入了无限的等待中。
(5)如何确保 N 个线程可以访问 N 个资源同时又不导致死?？
使用多线程的时候，一种非常简单的避免死?的方式就是：指定获取?的顺序，并强制线程
按照指定的顺序获取?。因此，如果所有的线程都是以同样的顺序加?和释放?，就不会出
现死?了。
